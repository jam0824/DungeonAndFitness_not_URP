using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.UI;
using TMPro;
using UnityEngine.SceneManagement;

public class ScenarioExec : MonoBehaviour
{
    public bool isStartCheck = false;
    public TextAsset scenario;
    //アイテムがフルだったときのキー
    string FULL_OF_ITEM_KEY = "FullOfItem";
    string MESSAGE_SE_KEY = "MessageNormal";

    float FADE_TIME = 0.5f;

    public ScenarioSystem scenarioSystem { set; get; }
    public AudioSource audioSource { set; get; }

    LabelFeelIcon labelFeelIcon;
    List<string[]> listScenarioCsv;
    List<GameObject> listSelectBoxCanvas;

    int lineNo = 0;
    //今一覧のシナリオ実行中か
    bool isNowScenarioExec = false;
    //今1行実行中か
    bool isNowLineExecuting = false;
    bool isLookAt = false;
    List<GameObject> listLookCharacter = new List<GameObject>();
    

    TextMeshProUGUI messageText;
    
    float messageSpeed = 0.05f;

    string nowMessage = "";


    // Start is called before the first frame update
    void Start()
    {
        //シーンスタート時に起動する場合
        if (isStartCheck) {
            scenarioSystem = SingletonGeneral.instance.scenarioSystem;
            InitMain();
        }
    }

    // Update is called once per frame
    void Update()
    {
        if (isLookAt) CommandLookAt(gameObject);
        if (listLookCharacter.Count != 0) LookFromObject(listLookCharacter);
           
    }

    //シナリオ実行時にこれを呼ぶ
    public void ScenarioExecution() {
        //1行実行中だったら何もしない。メッセージ重複防ぐ
        if (isNowLineExecuting) return;

        if (!isNowScenarioExec) {
            Init();
        }
        else {
            lineNo = exec(lineNo);
        }
    }

    //初期化
    public void Init() {
        //全体でイベントロック（誰かとイベント中）だったら何もしない
        if (scenarioSystem.GetLock()) return;
        scenarioSystem.SetLock(true);
        InitMain();
    }
    void InitMain() {
        LoadScenario();
        lineNo = GetScenarioLineNo();
        isNowScenarioExec = true;
        lineNo = exec(lineNo);
    }

    //行の実行。会話以外は会話などになるまで実行。
    public int exec(int no) {
        isNowLineExecuting = true;
        while (true) {
            DebugWindow.instance.DFDebug("LineNo:" + no);
            string[] line = listScenarioCsv[no];
            string command = line[0].ToLower();
            
            if (command == "") {
                no++;
                continue;
            }
            else if (command[0] == '#') {
                no++;
                continue;
            }
            else if (command == "look") {
                isLookAt = true;
                CommandLookAt(gameObject);
                DebugWindow.instance.DFDebug("Look");
                no++;
                continue;
            }
            else if (command == "lookfromobject") {
                ComandLookFromObject(line[1]);
                no++;
                continue;
            }
            else if (command == "lookoff") {
                isLookAt = false;
                no++;
                continue;
            }
            else if (command == "goto") {
                no = CommandGoto(line[1], listScenarioCsv);
                continue;
            }
            else if (command == "if") {
                no = CommandIf(line[1], line[2], line[3],listScenarioCsv);
                continue;
            }
            else if (command == "set") {
                CommandSwitchSet(line);
                no++;
                continue;
            }
            else if (command == "calc") {
                CommandSwitchCalcuration(line);
                no++;
                continue;
            }
            else if (command == "end") {
                CommandEnd();
                break;
            }
            else if (command == "select") {
                CommandSelect(no + 1, listScenarioCsv);
                break;
            }
            else if (command == "itemget") {
                CommandNormalItemGet(line[1], SingletonGeneral.instance.itemDb);
                no++;
                continue;
            }
            else if (command == "se") {
                CommandSe(line[1]);
                no++;
                continue;
            }
            else if (command == "save") {
                CommandSave();
                no++;
                continue;
            }
            else if (command == "feel") {
                CommandFeel(line[1]);
                no++;
                continue;
            }
            else if (command == "information") {
                CommandInformation(line[1]);
                no++;
                continue;
            }
            else if (command == "nocontroll") {
                CommandNoControll();
                no++;
                continue;
            }
            else if (command == "face") {
                CommandFace(line[1], line[2]);
                no++;
                continue;
            }
            else if (command == "messagemove") {
                CommandMessageMove(line[1], line[2]);
                no++;
                continue;
            }
            else if (command == "destroy") {
                CommandDestroy();
                break;
            }
            else if (command == "scene") {
                CommandScene(line[1]);
                break;
            }
            else if (command == "move") {
                CommandMove(line[1], no);
                break;
            }
            else if (command == "charactermove") {
                CommandCharacterMove(line[1], line[2], no);
                break;
            }
            else {
                CommandShowMessage(line);
                break;
            }
        }
        return no + 1;
    }

    //会話だった場合
    void CommandShowMessage(string[] line) {
        ShowWindowCanvas();
        nowMessage = FixMessage(string.Join(",", line));
        StartCoroutine(ShowMessage(nowMessage));
        DebugWindow.instance.DFDebug(line[0]);
    }

    //メッセージの編集
    string FixMessage(string line) {
        line = line.Replace("】", "】\n");
        line = line.Replace("]", "]\n");
        line = line.Replace("<br>", "\n");
        line = line.Replace(":", "");
        return line;
    }

    //メッセージを1文字ずつ表示する
    IEnumerator ShowMessage(string message) {

        for (int i = 0; i < message.Length; i++) {
            if (messageText == null) break;
            if (messageText.text == message) break;
            messageText.text += message[i];
            SingletonGeneral.instance.PlayOneShot(audioSource, MESSAGE_SE_KEY);
            yield return new WaitForSeconds(messageSpeed);
        }
        //会話が終わった
        isNowLineExecuting = false;
    }

    /// <summary>
    /// メッセージの一括表示
    /// </summary>
    /// <param name="message"></param>
    public void ShowMessageInstantly() {
        if(isNowLineExecuting == false) return;
        if (messageText == null) return;
        StopCoroutine(ShowMessage(""));
        messageText.text = nowMessage;
    }

    //メッセージキャンバス作成
    void ShowWindowCanvas() {
        if (messageText == null) {
            Vector3 addPos = new Vector3(0, -0.2f, 0);
            Vector3 pos = SingletonGeneral.instance.GetPosBetweenTargetAndFace(gameObject, addPos);
            messageText = scenarioSystem.ShowMessageWindow(
                pos, 
                SingletonGeneral.instance.GetQuaternionFace());
        }
        else {
            messageText.text = "";
        }
    }

    //メッセージキャンバスクローズ
    void CloseWindowCanvas() {
        messageText = null;
        scenarioSystem.CloseMessageWindow();
    }

    //select時の旗にはスクリプトでは#は付けない。飛ぶべきハタと区別がつかなくなるため
    void CommandSelect(int lineNo, List<string[]> scenario) {
        List<GameObject> listSelectBoxCanvas = new List<GameObject>();
        for (int i = 0; i < scenario.Count; i++) {
            string[] line = scenario[lineNo + i];
            if ((line[0] == "selectend")|| (line[0] == "")) break;
            string flagName = "#" + line[0];
            string message = line[1];
            GameObject selectBoxCanvas = MakeSelectBox(i);
            selectBoxCanvas.GetComponent<ScenarioSelectBox>().SetValues(gameObject, flagName, message);
            listSelectBoxCanvas.Add(selectBoxCanvas);
        }
        this.listSelectBoxCanvas = listSelectBoxCanvas;
    }

    //SELECTBOX作成
    GameObject MakeSelectBox(int boxCount) {
        float geta = 0.3f;
        float boxHeight = 0.2f; 

        Transform windowPosTransform = 
            SingletonGeneral.instance.scenarioSystem.MessageTextObject.transform;
        Vector3 windowPos = windowPosTransform.position;
        Quaternion r = windowPosTransform.rotation;
        windowPos.y += geta + boxCount * boxHeight;
        GameObject selectBoxCanvas = SingletonGeneral.instance.scenarioSystem.GetSelectBoxFromPool();
        selectBoxCanvas.SetActive(true);
        selectBoxCanvas.transform.position = windowPos;
        selectBoxCanvas.transform.rotation = r;

        return selectBoxCanvas;
    }

    /// <summary>
    /// 全てのセレクトボックスを非アクティブにする
    /// </summary>
    void UnenableAllSelectBox() {
        SingletonGeneral.instance.scenarioSystem.UnenableAllSelectBox();
    }

    //slectが実行された時
    public void ExecSelect(string flagName) {
        DebugWindow.instance.DFDebug("select flag name:" + flagName);
        int no = CommandGoto(flagName, this.listScenarioCsv);
        DebugWindow.instance.DFDebug("line:" + no);
        UnenableAllSelectBox();
        lineNo = exec(no);
    }

    //指定したラベルに飛ぶ
    int CommandGoto(string flagName, List<string[]> senario) {
        lineNo = 0;
        for (lineNo = 0; lineNo < senario.Count; lineNo++) {
            string[] checkLine = senario[lineNo];
            if (checkLine[0] == flagName) break;
        }
        if(lineNo == 0) 
            DebugWindow.instance.DFDebug("Goto flag is not found:" + flagName);

        lineNo++;
        return lineNo;
    }

    /// <summary>
    /// 条件がヒットしたときはtrueFlagへ、違うときはfalseFlagに飛ぶ
    /// 条件は&でつなげることができる
    /// </summary>
    /// <param name="condition"></param>
    /// <param name="trueFlag"></param>
    /// <param name="falseFlag"></param>
    /// <param name="scenario"></param>
    /// <returns></returns>
    int CommandIf(
        string condition,
        string trueFlag,
        string falseFlag,
        List<string[]> scenario) {
        int no = 0;
        string[] arrayCondition = condition.Split('&');
        bool isOk = scenarioSystem.isSwitch(new List<string>(arrayCondition));
        if (isOk) {
            no = CommandGoto(trueFlag, scenario);
        }
        else {
            no = CommandGoto(falseFlag, scenario);
        }
        return no;
    }

    //Playerを見るようにする
    void CommandLookAt(GameObject obj) {
        SingletonGeneral.instance.LookAt(
            SingletonGeneral.instance.face, 
            obj);
    }

    /// <summary>
    /// 指定したオブジェクトがPlayerを見るようにする
    /// </summary>
    /// <param name="objName"></param>
    void ComandLookFromObject(string objName) {
        GameObject obj = GameObject.Find(objName);
        listLookCharacter.Add(obj);
        DebugWindow.instance.DFDebug("LookFromObject : " + objName);
    }

    //登録されている全キャラクターをPlayerを見るようにする
    void LookFromObject(List<GameObject> listLookCharacter) {
        foreach(GameObject obj in listLookCharacter) {
            CommandLookAt(obj);
        }
    }

    //スイッチの数字の計算。+と-のみ。
    //コマンド,スイッチNo,符号,値
    void CommandSwitchCalcuration(string[] line) {
        string key = line[1];
        string sign = line[2];
        string value = line[3];
        scenarioSystem.CalcurationSwitch(key, sign, value);
    }

    //スイッチの値のセット。
    //コマンド,スイッチNo,値
    void CommandSwitchSet(string[] line) {
        if (line[1].Contains("=")) {
            line[1] = line[1].Replace(" ", "");
            string[] values = line[1].Split('=');
            scenarioSystem.SetSwitch(values[0], values[1]);
        }
        else {
            string key = line[1];
            string value = line[2];
            scenarioSystem.SetSwitch(key, value);
        }
    }

    

    //通常枠のアイテムを追加
    void CommandNormalItemGet(string itemNo, ItemDB itemDb) {
        if (itemDb.canAddItem(itemNo)) {
            DebugWindow.instance.DFDebug("アイテム追加：" + itemNo);
            itemDb.AddItem(itemNo);
        }
        else {
            SingletonGeneral.instance.labelInformationText.SetInformationLabel(FULL_OF_ITEM_KEY);
            Vector3 pos = gameObject.transform.position;
            pos.y += 1f;
            itemDb.MakeItemBag(itemNo, pos, gameObject.transform.rotation);
            DebugWindow.instance.DFDebug("アイテムバッグ作成：" + itemNo);
        }
    }

    //SEを鳴らす
    void CommandSe(string seName) {
        DebugWindow.instance.DFDebug("SE:" + seName);
        SingletonGeneral.instance.PlayOneShotNoAudioSource(seName);
    }

    /// <summary>
    /// Saveする
    /// </summary>
    void CommandSave() {
        DebugWindow.instance.DFDebug("SAVE");
        SingletonGeneral.instance.saveLoadSystem.Save();
        SingletonGeneral.instance.labelInformationText.SetInformationLabel("Save");
    }

    /// <summary>
    /// FeelIconを出す
    /// Smile,Angry,Sad,Surprise,Tere
    /// </summary>
    /// <param name="iconKey"></param>
    void CommandFeel(string iconKey) {
        if(labelFeelIcon == null) {
            GameObject feelObject = transform.Find("NpcSet/FeelIcon").gameObject;
            labelFeelIcon = feelObject.GetComponent<LabelFeelIcon>();
        }
        labelFeelIcon.SetIcon(iconKey, transform.rotation);
    }

    /// <summary>
    /// 画面下のインフォメーションにメッセージを表示する
    /// </summary>
    /// <param name="labelKey"></param>
    void CommandInformation(string labelKey) {
        SingletonGeneral.instance.labelInformationText.SetInformationLabel(labelKey);
    }

    /// <summary>
    /// ScenarioExecがついたオブジェクトを消去する
    /// </summary>
    void CommandDestroy() {
        DebugWindow.instance.DFDebug("シナリオによるDestroy");
        CloseWindowCanvas();
        ResetFlagMain();
        Destroy(gameObject);
    }

    /// <summary>
    /// 指定した名前のシーンに切り替える
    /// フェード付き
    /// </summary>
    /// <param name="sceneName"></param>
    void CommandScene(string sceneName) {
        DebugWindow.instance.DFDebug("シーン切り替え：" + sceneName);
        OVRScreenFade ovrScreenFade = GameObject.Find("CenterEyeAnchor").GetComponent<OVRScreenFade>();
        ovrScreenFade.FadeOut();
        StartCoroutine(ChangeScene(sceneName, FADE_TIME));
    }

    IEnumerator ChangeScene(string sceneName, float waitTime) {
        yield return new WaitForSeconds(waitTime);
        ResetFlagMain();
        SceneManager.LoadScene(sceneName);
    }

    /// <summary>
    /// キャラクターの同じシーン内の移動。フェード付き
    /// </summary>
    /// <param name="targetObjectName"></param>
    /// <param name="no"></param>
    void CommandMove(string targetObjectName, int no) {
        DebugWindow.instance.DFDebug("移動：" + targetObjectName);
        StartCoroutine(Move(targetObjectName, no));
    }
    //コールチンでフェード処理
    IEnumerator Move(string targetObjectName, int no) {
        scenarioSystem.CameraC.GetComponent<OVRScreenFade>().FadeOut();
        yield return new WaitForSeconds(FADE_TIME);
        MoveToTargetObject(targetObjectName);
        scenarioSystem.CameraC.GetComponent<OVRScreenFade>().FadeIn();
        yield return new WaitForSeconds(FADE_TIME);
        //シナリオはbreakしてるので、フェードが終わった後に再度シナリオを呼び出す
        lineNo = exec(no + 1);
    }

    //Playerを指定したオブジェクトと同じ位置、角度で移動する
    void MoveToTargetObject(string targetObjectName) {
        GameObject targetObject = GameObject.Find(targetObjectName);
        Vector3 pos = targetObject.transform.position;
        DebugWindow.instance.DFDebug("taretPos:" + pos);
        GameObject player = GameObject.Find("Player");
        //キャラクターコントローラーを切らないと移動しないことがある
        player.GetComponent<CharacterController>().enabled = false;
        player.transform.position = pos;
        player.transform.rotation = targetObject.transform.rotation;
        DebugWindow.instance.DFDebug("playerPos:" + GameObject.Find("Player").transform.position);
        player.GetComponent<CharacterController>().enabled = true;
    }

    /// <summary>
    /// Playerのコントローラーでの移動を禁止する
    /// </summary>
    void CommandNoControll() {
        PlayerView.instance.canControll = false;
        DebugWindow.instance.DFDebug("Playerの操作無効化");
    }

    /// <summary>
    /// 指定したオブジェクト名の表情を変える
    /// </summary>
    /// <param name="characterName"></param>
    /// <param name="emotion"></param>
    void CommandFace(string characterName, string emotion) {
        //表情は大文字で。
        emotion = emotion.ToUpper();

        GameObject.Find(characterName)
            .GetComponent<AnimationSystem>()
            .SetFace(characterName, emotion);
        DebugWindow.instance.DFDebug("表情変更:" + characterName + "->" + emotion);
    }

    /// <summary>
    /// 指定したキャラクターをanchorまで移動させる
    /// </summary>
    /// <param name="characterName"></param>
    /// <param name="anchorName"></param>
    /// <param name="no"></param>
    void CommandCharacterMove(string characterName, string anchorName, int no) {
        GameObject anchor = GameObject.Find(anchorName);
        GameObject character = GameObject.Find(characterName);
        character.GetComponent<AnimationSystem>().MoveToObject(this, no, anchor);
        DebugWindow.instance.DFDebug(characterName + "移動開始。" + anchorName + "まで");
    }


    //キャラクター移動時、キャラクター側から呼ばれてストップする
    public void StopCharacterMove(int no) {
        DebugWindow.instance.DFDebug("キャラクター移動完了。シナリオ再開:" + (no + 1));
        //シナリオはbreakしてるので、フェードが終わった後に再度シナリオを呼び出す
        lineNo = exec(no + 1);
    }

    /// <summary>
    /// メッセージウィンドウを移動する
    /// </summary>
    /// <param name="characterName"></param>
    /// <param name="positionName"></param>
    void CommandMessageMove(string characterName, string positionName) {
        GameObject obj = GameObject.Find(characterName);
        Quaternion r = SingletonGeneral.instance.GetQuaternionFace();
        positionName = positionName.ToLower();
        switch (positionName) {
            case "center":
                Vector3 pos = SingletonGeneral.instance.GetPosBetweenTargetAndFace(obj, Vector3.zero);
                scenarioSystem.MoveMessageWindow(pos, r);
                break;
        }
    }



    //会話終了
    void CommandEnd() {
        CloseWindowCanvas();

        DebugWindow.instance.DFDebug("会話終了");
        //会話終了後、判定と重なっているためすぐ次の話になる。コールチンで待ち時間を入れる
        StartCoroutine("ResetFlag");
    }

    //各種フラグリセット
    IEnumerator ResetFlag() {
        yield return new WaitForSeconds(0.5f);
        ResetFlagMain();
    }

    void ResetFlagMain() {
        isNowLineExecuting = false;
        isNowScenarioExec = false;
        isLookAt = false;
        messageText = null;
        listLookCharacter = new List<GameObject>();
        PlayerView.instance.canControll = true;
        scenarioSystem.SetLock(false);
    }

    //シナリオファイルのロード。シナリオはprefabにアタッチされたもの。
    public void LoadScenario() {
        DebugWindow.instance.DFDebug("シナリオ呼び出し");
        List<string[]> tsvData = FQCommon.Common.LoadTsvFileFromTextAsset(scenario);

        listScenarioCsv = GetLanguageText(tsvData, SingletonGeneral.instance.LanguageMode);
    }

    //日本語と英語はタブ区切りされている。
    //各言語でのパラメーターはcsv区切りされている
    List<string[]> GetLanguageText(List<string[]> tsvData, string language) {
        List<string[]> returnData = new List<string[]>();
        int languageNo = 0;
        if (language == "english") languageNo = 1;

        foreach (string[] data in tsvData) {
            string[] csvLine = data[languageNo].Split(',');
            returnData.Add(csvLine);
        }
        return returnData;
    }


    //実行可能なswitch行を探す。なかった場合は0(最初の行)を返す。
    int GetScenarioLineNo() {
        int no = 0;
        for (int i = 0; i < listScenarioCsv.Count; i++) {
            string[] line = listScenarioCsv[i];
            if(line[0] == "switch") {
                if (isSwitch(line)) {
                    no = i + 1;
                    break;
                }
            }
        }
        return no;
    }

    //switchコマンドが真だった場合。
    //key=1,key=1のようにkey = valueで書く。今は=でアンドのみ。
    bool isSwitch(string[] line) {
        List<string> listValue = new List<string>();
        for (int i = 1; i < line.Length; i++) {
            listValue.Add(line[i]);
        }
        return scenarioSystem.isSwitch(listValue);
    }

    public bool GetIsNowLineExecuting() {
        return isNowLineExecuting;
    }


}
